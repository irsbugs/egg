/* egg.c generated by valac 0.40.19, the Vala compiler
 * generated from egg.vala, do not modify */



#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <glib/gstdio.h>
#include <stdio.h>


#define TYPE_EGG (egg_get_type ())
#define EGG(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_EGG, Egg))
#define EGG_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_EGG, EggClass))
#define IS_EGG(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_EGG))
#define IS_EGG_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_EGG))
#define EGG_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_EGG, EggClass))

typedef struct _Egg Egg;
typedef struct _EggClass EggClass;
typedef struct _EggPrivate EggPrivate;
enum  {
	EGG_0_PROPERTY,
	EGG_NUM_PROPERTIES
};
static GParamSpec* egg_properties[EGG_NUM_PROPERTIES];
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define _g_date_time_unref0(var) ((var == NULL) ? NULL : (var = (g_date_time_unref (var), NULL)))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

struct _Egg {
	GObject parent_instance;
	EggPrivate * priv;
};

struct _EggClass {
	GObjectClass parent_class;
};


static gpointer egg_parent_class = NULL;

GType egg_get_type (void) G_GNUC_CONST;
static void egg_greeting (Egg* self);
static void egg_start_egg_timer (Egg* self,
                          gint duration);
static void egg_time_elapsed (Egg* self);
static void egg_time_remaining (Egg* self);
static void egg_main (gchar** args,
               int args_length1);
Egg* egg_new (void);
Egg* egg_construct (GType object_type);
static void _vala_array_destroy (gpointer array,
                          gint array_length,
                          GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array,
                       gint array_length,
                       GDestroyNotify destroy_func);
static gint _vala_array_length (gpointer array);


static void
egg_greeting (Egg* self)
{
	g_return_if_fail (self != NULL);
	g_print ("\nEgg Timer - 0.1. written in Vala.\n");
}


static void
egg_start_egg_timer (Egg* self,
                     gint duration)
{
	gint64 seconds_now = 0LL;
	gchar* time_stamp = NULL;
	gchar* _tmp0_;
	gchar* text_save = NULL;
	gchar* _tmp1_;
	gchar* _tmp2_;
	gchar* _tmp3_;
	gchar* _tmp4_;
	gchar* _tmp5_;
	gchar* _tmp6_;
	GDateTime* dt = NULL;
	GDateTime* _tmp10_;
	FILE* _tmp11_;
	gchar* _tmp12_;
	gchar* _tmp13_;
	GError* _inner_error0_ = NULL;
	g_return_if_fail (self != NULL);
	seconds_now = g_get_real_time () / 1000000;
	_tmp0_ = g_strdup_printf ("%" G_GINT64_FORMAT, seconds_now);
	time_stamp = _tmp0_;
	_tmp1_ = g_strconcat (time_stamp, ",", NULL);
	_tmp2_ = _tmp1_;
	_tmp3_ = g_strdup_printf ("%i", duration);
	_tmp4_ = _tmp3_;
	_tmp5_ = g_strconcat (_tmp2_, _tmp4_, NULL);
	_tmp6_ = _tmp5_;
	_g_free0 (_tmp4_);
	_g_free0 (_tmp2_);
	text_save = _tmp6_;
	{
		g_file_set_contents ("/tmp/egg.data", text_save, (gssize) -1, &_inner_error0_);
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			goto __catch0_g_error;
		}
	}
	goto __finally0;
	__catch0_g_error:
	{
		GError* e = NULL;
		FILE* _tmp7_;
		GError* _tmp8_;
		const gchar* _tmp9_;
		e = _inner_error0_;
		_inner_error0_ = NULL;
		_tmp7_ = stderr;
		_tmp8_ = e;
		_tmp9_ = _tmp8_->message;
		fprintf (_tmp7_, "Error: %s", _tmp9_);
		_g_error_free0 (e);
	}
	__finally0:
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		_g_free0 (text_save);
		_g_free0 (time_stamp);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
		g_clear_error (&_inner_error0_);
		return;
	}
	_tmp10_ = g_date_time_new_now_local ();
	dt = _tmp10_;
	_tmp11_ = stdout;
	_tmp12_ = g_date_time_format (dt, "\n\tEgg timer started: %e %b %Y %k:%M:%S\n");
	_tmp13_ = _tmp12_;
	fputs (_tmp13_, _tmp11_);
	_g_free0 (_tmp13_);
	g_print ("\tTimer set for: %d seconds\n", duration);
	_g_date_time_unref0 (dt);
	_g_free0 (text_save);
	_g_free0 (time_stamp);
}


static gint64
int64_parse (const gchar* str)
{
	gint64 result = 0LL;
	g_return_val_if_fail (str != NULL, 0LL);
	result = g_ascii_strtoll (str, NULL, (guint) 0);
	return result;
}


static void
egg_time_elapsed (Egg* self)
{
	GError* _inner_error0_ = NULL;
	g_return_if_fail (self != NULL);
	{
		gchar* text = NULL;
		gchar* _tmp0_ = NULL;
		gchar** data = NULL;
		gchar** _tmp1_;
		gchar** _tmp2_;
		gint data_length1;
		gint _data_size_;
		gint64 time_start = 0LL;
		gchar** _tmp3_;
		gint _tmp3__length1;
		const gchar* _tmp4_;
		gint64 time_now = 0LL;
		gint64 time_diff = 0LL;
		gint64 _tmp5_;
		gint64 _tmp6_;
		gint64 _tmp7_;
		g_file_get_contents ("/tmp/egg.data", &_tmp0_, NULL, &_inner_error0_);
		_g_free0 (text);
		text = _tmp0_;
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			_g_free0 (text);
			goto __catch1_g_error;
		}
		_tmp2_ = _tmp1_ = g_strsplit (text, ",", 0);
		data = _tmp2_;
		data_length1 = _vala_array_length (_tmp1_);
		_data_size_ = data_length1;
		_tmp3_ = data;
		_tmp3__length1 = data_length1;
		_tmp4_ = _tmp3_[0];
		time_start = int64_parse (_tmp4_);
		time_now = g_get_real_time () / 1000000;
		_tmp5_ = time_now;
		_tmp6_ = time_start;
		time_diff = _tmp5_ - _tmp6_;
		_tmp7_ = time_diff;
		g_print ("\n\tTime Elapsed: %" G_GINT64_FORMAT "\n", _tmp7_);
		data = (_vala_array_free (data, data_length1, (GDestroyNotify) g_free), NULL);
		_g_free0 (text);
	}
	goto __finally1;
	__catch1_g_error:
	{
		GError* e = NULL;
		FILE* _tmp8_;
		GError* _tmp9_;
		const gchar* _tmp10_;
		e = _inner_error0_;
		_inner_error0_ = NULL;
		_tmp8_ = stderr;
		_tmp9_ = e;
		_tmp10_ = _tmp9_->message;
		fprintf (_tmp8_, "Error: %s", _tmp10_);
		_g_error_free0 (e);
	}
	__finally1:
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
		g_clear_error (&_inner_error0_);
		return;
	}
}


static void
egg_time_remaining (Egg* self)
{
	GError* _inner_error0_ = NULL;
	g_return_if_fail (self != NULL);
	{
		gchar* text = NULL;
		gchar* _tmp0_ = NULL;
		gchar** data = NULL;
		gchar** _tmp1_;
		gchar** _tmp2_;
		gint data_length1;
		gint _data_size_;
		gint64 time_start = 0LL;
		gchar** _tmp3_;
		gint _tmp3__length1;
		const gchar* _tmp4_;
		gint64 duration = 0LL;
		gchar** _tmp5_;
		gint _tmp5__length1;
		const gchar* _tmp6_;
		gint64 time_now = 0LL;
		gint64 time_diff = 0LL;
		gint64 _tmp7_;
		gint64 _tmp8_;
		gint64 _tmp9_;
		gint64 _tmp10_;
		g_file_get_contents ("/tmp/egg.data", &_tmp0_, NULL, &_inner_error0_);
		_g_free0 (text);
		text = _tmp0_;
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			_g_free0 (text);
			goto __catch2_g_error;
		}
		_tmp2_ = _tmp1_ = g_strsplit (text, ",", 0);
		data = _tmp2_;
		data_length1 = _vala_array_length (_tmp1_);
		_data_size_ = data_length1;
		_tmp3_ = data;
		_tmp3__length1 = data_length1;
		_tmp4_ = _tmp3_[0];
		time_start = int64_parse (_tmp4_);
		_tmp5_ = data;
		_tmp5__length1 = data_length1;
		_tmp6_ = _tmp5_[1];
		duration = int64_parse (_tmp6_);
		time_now = g_get_real_time () / 1000000;
		_tmp7_ = time_start;
		_tmp8_ = duration;
		_tmp9_ = time_now;
		time_diff = (_tmp7_ + _tmp8_) - _tmp9_;
		_tmp10_ = time_diff;
		g_print ("\n\tTime Remaining: %" G_GINT64_FORMAT "\n", _tmp10_);
		data = (_vala_array_free (data, data_length1, (GDestroyNotify) g_free), NULL);
		_g_free0 (text);
	}
	goto __finally2;
	__catch2_g_error:
	{
		GError* e = NULL;
		FILE* _tmp11_;
		GError* _tmp12_;
		const gchar* _tmp13_;
		e = _inner_error0_;
		_inner_error0_ = NULL;
		_tmp11_ = stderr;
		_tmp12_ = e;
		_tmp13_ = _tmp12_->message;
		fprintf (_tmp11_, "Error: %s", _tmp13_);
		_g_error_free0 (e);
	}
	__finally2:
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
		g_clear_error (&_inner_error0_);
		return;
	}
}


static void
egg_main (gchar** args,
          int args_length1)
{
	Egg* egg = NULL;
	Egg* _tmp0_;
	Egg* _tmp1_;
	gint input = 0;
	gboolean is_looping = FALSE;
	_tmp0_ = egg_new ();
	egg = _tmp0_;
	_tmp1_ = egg;
	egg_greeting (_tmp1_);
	is_looping = TRUE;
	while (TRUE) {
		gboolean _tmp2_;
		FILE* _tmp3_;
		FILE* _tmp4_;
		gint _tmp5_ = 0;
		gint _tmp6_;
		gint _tmp8_;
		_tmp2_ = is_looping;
		if (!_tmp2_) {
			break;
		}
		_tmp3_ = stdout;
		fprintf (_tmp3_, "\n" \
"            Egg Timer Menu:\n" \
"                1. Start Egg Timer\n" \
"                2. Time Elapsed\n" \
"                3. Time Remaining\n" \
"                4. Stop Egg Timer\n" \
"                \n" \
"                Selection: ");
		_tmp4_ = stdin;
		_tmp6_ = fscanf (_tmp4_, "%d", &_tmp5_);
		input = _tmp5_;
		if (_tmp6_ != 1) {
			FILE* _tmp7_;
			g_print ("\n\tError Non-Numeric. Enter 1 to 4...\n");
			_tmp7_ = stdin;
			fscanf (_tmp7_, "%*s");
			continue;
		}
		_tmp8_ = input;
		switch (_tmp8_) {
			case 1:
			{
				if (args_length1 < 2) {
					Egg* _tmp9_;
					_tmp9_ = egg;
					egg_start_egg_timer (_tmp9_, 60);
				} else {
					Egg* _tmp10_;
					const gchar* _tmp11_;
					_tmp10_ = egg;
					_tmp11_ = args[1];
					egg_start_egg_timer (_tmp10_, atoi (_tmp11_));
				}
				break;
			}
			case 2:
			{
				Egg* _tmp12_;
				_tmp12_ = egg;
				egg_time_elapsed (_tmp12_);
				break;
			}
			case 3:
			{
				Egg* _tmp13_;
				_tmp13_ = egg;
				egg_time_remaining (_tmp13_);
				break;
			}
			case 4:
			{
				is_looping = FALSE;
				g_print ("\n\tBon appetit!\n");
				break;
			}
			default:
			{
				gint _tmp14_;
				_tmp14_ = input;
				g_print ("\n\tInvalid Integer: %d. Enter 1 to 4...\n", _tmp14_);
				break;
			}
		}
	}
	_g_object_unref0 (egg);
}


int
main (int argc,
      char ** argv)
{
	egg_main (argv, argc);
	return 0;
}


Egg*
egg_construct (GType object_type)
{
	Egg * self = NULL;
	self = (Egg*) g_object_new (object_type, NULL);
	return self;
}


Egg*
egg_new (void)
{
	return egg_construct (TYPE_EGG);
}


static void
egg_class_init (EggClass * klass)
{
	egg_parent_class = g_type_class_peek_parent (klass);
}


static void
egg_instance_init (Egg * self)
{
}


/**
 * Egg Timer
 * egg.vala
 * 
 * Objective: Compile in C and expose the API functions so that other languages
 * may have bindings to these functions
 * 
 * Reference:
 * http://helgo.net/simon/introspection-tutorial/stepone.xhtml
 * 
 * Ian Stewart
 * 2020-06-02
 */
GType
egg_get_type (void)
{
	static volatile gsize egg_type_id__volatile = 0;
	if (g_once_init_enter (&egg_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (EggClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) egg_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Egg), 0, (GInstanceInitFunc) egg_instance_init, NULL };
		GType egg_type_id;
		egg_type_id = g_type_register_static (G_TYPE_OBJECT, "Egg", &g_define_type_info, 0);
		g_once_init_leave (&egg_type_id__volatile, egg_type_id);
	}
	return egg_type_id__volatile;
}


static void
_vala_array_destroy (gpointer array,
                     gint array_length,
                     GDestroyNotify destroy_func)
{
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void
_vala_array_free (gpointer array,
                  gint array_length,
                  GDestroyNotify destroy_func)
{
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static gint
_vala_array_length (gpointer array)
{
	int length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}



